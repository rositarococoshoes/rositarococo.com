
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sofía - Asistente Virtual</title>
    <style>
        :root {
            --primary-color: #E91E63;
            --secondary-color: #F8BBD0;
            --background-color: #f5f5f5;
            --text-color: #333;
            --assistant-bg: #fff;
            --user-bg: #E1F5FE;
            --tool-bg: #F1F8E9; /* Verde muy claro para herramientas */
            --tool-color: #33691E; /* Verde oscuro para texto de herramientas */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        body {
            margin: 0;
            font-family: var(--font-family);
            background-color: var(--background-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: var(--text-color);
        }
        .chat-container {
            width: 100%;
            max-width: 800px;
            height: 90vh;
            max-height: 800px;
            background-color: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 16px 24px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            flex-shrink: 0;
        }
        .messages {
            flex-grow: 1;
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .message {
            display: flex;
            margin-bottom: 16px;
            max-width: 80%;
        }
        .message .bubble {
            padding: 12px 18px;
            border-radius: 20px;
            line-height: 1.5;
            display: flex;
            align-items: center;
            gap: 8px; /* Espacio entre ícono y texto */
        }
        .message.assistant {
            align-self: flex-start;
        }
        .message.assistant .bubble {
            background-color: var(--assistant-bg);
            border: 1px solid #eee;
            border-top-left-radius: 4px;
        }
        .message.user {
            align-self: flex-end;
        }
        .message.user .bubble {
            background-color: var(--user-bg);
            border-top-right-radius: 4px;
        }
        .message .bubble.tool-call {
            background-color: var(--tool-bg);
            color: var(--tool-color);
            font-style: italic;
        }
        .message .bubble .tool-icon {
            width: 18px;
            height: 18px;
            fill: var(--tool-color);
        }
        .status-bar {
            padding: 8px 24px;
            font-style: italic;
            color: #888;
            height: 20px;
            text-align: center;
            flex-shrink: 0;
            font-size: 0.9rem;
        }
        .controls {
            padding: 24px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px; /* Espacio entre botones */
            background-color: #fff;
            flex-shrink: 0;
        }
        .control-button {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            border: none;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        #mic-button {
            background-color: var(--primary-color);
            box-shadow: 0 4px 15px rgba(233, 30, 99, 0.4);
        }
        #mic-button:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(233, 30, 99, 0.5);
        }
        #mic-button.recording {
            background-color: #F44336;
            animation: pulse 1.5s infinite;
        }
        #mic-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }
        .control-button svg {
            width: 32px;
            height: 32px;
        }

        /* --- Estilos del Indicador de "Hablando" --- */
        .speaking-indicator, .listening-indicator {
            display: flex;
            align-items: center;
        }
        .speaking-indicator span, .listening-indicator span {
            height: 8px;
            width: 8px;
            margin: 0 2px;
            background-color: #aaa;
            border-radius: 50%;
            display: inline-block;
            animation: ellipsis 1.4s infinite both;
        }
        .speaking-indicator span:nth-child(1), .listening-indicator span:nth-child(1) { animation-delay: -0.32s; }
        .speaking-indicator span:nth-child(2), .listening-indicator span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes ellipsis {
            0%, 80%, 100% {
                transform: scale(0);
            } 40% {
                transform: scale(1.0);
            }
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(244, 67, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); }
        }
    </style>
<script type="importmap">
{
  "imports": {
    "ws": "https://aistudiocdn.com/ws@^8.18.3",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.21.0",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "classnames": "https://aistudiocdn.com/classnames@^2.5.1",
    "eventemitter3": "https://aistudiocdn.com/eventemitter3@^5.0.1",
    "lodash": "https://aistudiocdn.com/lodash@^4.17.21",
    "zustand": "https://aistudiocdn.com/zustand@^5.0.8"
  }
}
</script>
</head>
<body>
    <div class="chat-container">
        <header>Habla con tu Asistente</header>
        
        <div class="messages" id="messages">
            <!-- Los mensajes de chat aparecerán aquí -->
        </div>
        <div class="status-bar" id="status-bar">Presiona el micrófono para comenzar</div>
        <div class="controls">
            <button id="mic-button" class="control-button" title="Iniciar conversación">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"></path>
                    <path d="M17 11h-1c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92z"></path>
                </svg>
            </button>
        </div>
    </div>

    <script type="module">
        // --- CONFIGURACIÓN ---
        const PROXY_WEBSOCKET_URL = 'wss://sofia-proxy.odontolab.co/';

        // --- ELEMENTOS DEL DOM ---
        const micButton = document.getElementById('mic-button');
        const messagesContainer = document.getElementById('messages');
        const statusBar = document.getElementById('status-bar');

        // --- ICONOS SVG para herramientas ---
        const ICON_TOOL_PROCESSING = `<svg class="tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19.44 12.99l-.01.02c.04-.33.08-.67.08-1.01 0-.34-.03-.66-.07-.99l.01.02 2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.24 14.25 2 14 2h-4c-.25 0-.46.24-.49.54l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65-.01-.02c-.04.33-.07.65-.07.99s.03.68.08 1.01l.01-.02-2.11 1.65c-.19-.15-.24-.42-.12-.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.3.24.54.49.54h4c.25 0 .46-.24.49.54l.38-2.65c.61.25 1.17-.59 1.69.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>`;
        const ICON_TOOL_SUCCESS = `<svg class="tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 16.17l7.59-7.59L19 10l-9 9z"/></svg>`;

        // --- ESTADO DE LA APLICACIÓN ---
        let isRecording = false;
        let ws = null;
        let audioStream = null;
        let inputAudioContext = null;
        let audioWorkletNode = null;
        const outputAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
        let nextStartTime = 0;
        const sources = new Set();
        let currentUserMessage = null;
        let currentAssistantMessage = null;

        // --- LÓGICA PRINCIPAL ---
        micButton.addEventListener('click', async () => {
            isRecording ? stopConversation() : await startConversation();
        });

        document.addEventListener('DOMContentLoaded', () => {
            clearChat();
        });
        
        function getSystemInstruction() {
            return `Sos un asistente de IA de Argentina. Tu personalidad es amigable, empática y muy conversacional. Hablá con un acento argentino natural, como el de Buenos Aires, usando expresiones locales y el voseo (usar 'vos' en lugar de 'tú'). Tu objetivo es que la conversación se sienta humana y cercana, no como la de un robot. Mantené un tono servicial y comprensivo en todo momento. Aún tienes la capacidad de usar la herramienta 'registrar_pedido' si el usuario te da todos los datos necesarios (nombre, teléfono, localidad, dirección, modelo, talle y método de pago), pero no te ofrezcas a tomar pedidos activamente, solo responde si el usuario insiste y provee toda la información.`;
        }
        
        function addMessage(text, sender, options = {}) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender);
            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bubble');
            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            let indicatorDiv = null;
            let icon = null;

            if (options.isTool) {
                bubbleDiv.classList.add('tool-call');
                icon = document.createElement('div');
                icon.innerHTML = ICON_TOOL_PROCESSING;
                bubbleDiv.appendChild(icon);
            }
            if (options.isSpeaking) {
                indicatorDiv = document.createElement('div');
                indicatorDiv.classList.add('speaking-indicator');
                indicatorDiv.innerHTML = '<span></span><span></span><span></span>';
                bubbleDiv.appendChild(indicatorDiv);
            }
            if (options.isListening) {
                indicatorDiv = document.createElement('div');
                indicatorDiv.classList.add('listening-indicator');
                indicatorDiv.innerHTML = '<span></span><span></span><span></span>';
                bubbleDiv.insertBefore(indicatorDiv, bubbleDiv.firstChild);
            }
            
            bubbleDiv.appendChild(textSpan);
            messageDiv.appendChild(bubbleDiv);
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            return { element: messageDiv, bubble: bubbleDiv, textContent: textSpan, indicator: indicatorDiv, icon };
        }


        function updateMessage(message, newText) {
            message.textContent.textContent = newText;
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function startConversation() {
            micButton.disabled = true;
            
            if (outputAudioContext.state === 'suspended') {
                await outputAudioContext.resume();
            }
            
            clearChat(); 
            updateStatus('Solicitando permiso del micrófono...', 'info');

            try {
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                updateStatus('Conectando con el asistente...', 'info');
                ws = await setupWebSocket();
                isRecording = true;
                micButton.classList.add('recording');
                micButton.title = 'Detener conversación';
                micButton.disabled = false;
            } catch (error) {
                console.error('Error al iniciar la conversación:', error);
                const errorMessage = error instanceof Event ? "No se pudo conectar con el asistente. Revisa la URL y el estado del servidor." : "No se pudo acceder al micrófono.";
                updateStatus(errorMessage, 'error');
                if(ws) ws.close();
                else cleanupConversation();
            }
        }

        function stopConversation() {
            updateStatus('Terminando conversación...', 'info');
            if (ws) ws.close();
            else cleanupConversation();
        }

        function setupWebSocket() {
            return new Promise((resolve, reject) => {
                const socket = new WebSocket(PROXY_WEBSOCKET_URL);
                socket.onopen = () => {
                    console.log('WebSocket conectado.');
                    updateStatus('Iniciando sesión...', 'info');
                    socket.send(JSON.stringify({ action: 'start', systemInstruction: getSystemInstruction() }));
                };
                socket.onmessage = async (event) => {
                    const message = JSON.parse(event.data);
                    if (message.type === 'status' && message.message === 'connected') {
                        console.log('Sesión con Gemini establecida.');
                        updateStatus('Habla ahora...', 'listening');
                        await startAudioStreaming();
                        resolve(socket);
                    } else if (message.type === 'gemini_response') {
                        handleGeminiResponse(message.data);
                    } else if (message.type === 'error') {
                        console.error('Error del servidor:', message.message);
                        updateStatus(`Error: ${message.message}`, 'error');
                        reject(new Error(message.message));
                    }
                };
                socket.onerror = (error) => reject(error);
                socket.onclose = (event) => {
                    console.log(`WebSocket desconectado. Código: ${event.code} Razón: ${event.reason}`);
                    cleanupConversation(event.code);
                };
            });
        }

        function cleanupConversation(closeCode) {
            if(isRecording) {
                 stopAudioStreaming();
            }
            isRecording = false;
            micButton.classList.remove('recording');
            micButton.title = 'Iniciar conversación';
            micButton.disabled = false;
            currentUserMessage = null;
            currentAssistantMessage = null;
            ws = null;
            
            let statusMessage = 'Conexión terminada. Presiona el micrófono para empezar de nuevo.';
            let statusType = 'info';

            if (closeCode === 1006) { // Cierre anormal (ej. red, servidor caído)
                statusMessage = 'Se perdió la conexión. Revisa tu red o el estado del servidor.';
                statusType = 'error';
            } else if (closeCode && closeCode !== 1000 && closeCode !== 1005) { // Otros códigos de error
                statusMessage = `Conexión cerrada inesperadamente (Código: ${closeCode}). Intenta de nuevo.`;
                statusType = 'error';
            }
            updateStatus(statusMessage, statusType);
        }

        function handleGeminiResponse(data) {
            const { serverContent, toolCall } = data;

            if (serverContent?.interrupted) {
                stopAllPlayback();
            }

            if (serverContent?.inputTranscription?.text) {
                const text = serverContent.inputTranscription.text;
                if (!currentUserMessage) {
                    currentUserMessage = addMessage("", 'user', { isListening: true });
                }
                updateMessage(currentUserMessage, currentUserMessage.textContent.textContent + text);
            }
            const hasAssistantOutput = serverContent?.outputTranscription?.text || serverContent?.modelTurn?.parts[0]?.inlineData?.data;
            if (hasAssistantOutput && !currentAssistantMessage) {
                updateStatus('Asistente respondiendo...', 'info');
                currentAssistantMessage = addMessage('', 'assistant', { isSpeaking: true });
            }
            if (serverContent?.outputTranscription?.text) {
                 updateMessage(currentAssistantMessage, currentAssistantMessage.textContent.textContent + serverContent.outputTranscription.text);
            }
            if (serverContent?.modelTurn?.parts[0]?.inlineData?.data) {
                decodeAndPlayAudio(serverContent.modelTurn.parts[0].inlineData.data);
            }
            if (toolCall) {
                handleToolCall(toolCall);
            }
            if (serverContent?.turnComplete) {
                if (currentUserMessage?.indicator) {
                    currentUserMessage.indicator.remove();
                    currentUserMessage.indicator = null;
                }
                if (currentAssistantMessage?.indicator) {
                    currentAssistantMessage.indicator.remove();
                    currentAssistantMessage.indicator = null;
                }
                currentUserMessage = null;
                currentAssistantMessage = null;
                updateStatus('Puedes hablar ahora...', 'listening');
            }
        }
        
        function stopAllPlayback() {
            for (const source of sources) {
                source.stop(0);
            }
            sources.clear();
            nextStartTime = 0;
        }

        function handleToolCall(toolCall) {
            const functionCall = toolCall.functionCalls[0];
            if (functionCall.name === 'registrar_pedido') {
                const toolMessage = addMessage('Registrando pedido...', 'assistant', { isTool: true });

                setTimeout(() => {
                    if(toolMessage.icon) toolMessage.icon.innerHTML = ICON_TOOL_SUCCESS;
                    updateMessage(toolMessage, '¡Pedido registrado con éxito!');

                    ws?.send(JSON.stringify({
                        action: 'tool_response',
                        response: {
                            id: functionCall.id,
                            name: functionCall.name,
                            response: { result: "OK, pedido registrado con éxito." }
                        }
                    }));
                }, 1500);
            }
        }

        const audioWorkletCode = `
        class PCMProcessor extends AudioWorkletProcessor {
            process(inputs) {
                const input = inputs[0];
                if (input.length > 0) {
                    const pcmData = new Int16Array(input[0].length);
                    for (let i = 0; i < input[0].length; i++) {
                        pcmData[i] = Math.max(-1, Math.min(1, input[0][i])) * 32767;
                    }
                    this.port.postMessage(pcmData.buffer, [pcmData.buffer]);
                }
                return true;
            }
        }
        registerProcessor('pcm-processor', PCMProcessor);`;

        async function startAudioStreaming() {
            if (!audioStream) return;
            inputAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
            const mediaStreamSource = inputAudioContext.createMediaStreamSource(audioStream);
            const blob = new Blob([audioWorkletCode], { type: 'application/javascript' });
            const workletURL = URL.createObjectURL(blob);
            await inputAudioContext.audioWorklet.addModule(workletURL);
            audioWorkletNode = new AudioWorkletNode(inputAudioContext, 'pcm-processor');
            audioWorkletNode.port.onmessage = (event) => {
                if (!isRecording || !ws || ws.readyState !== WebSocket.OPEN) return;
                ws.send(JSON.stringify({
                    action: 'audio_chunk',
                    chunk: { data: uint8ArrayToBase64(new Uint8Array(event.data)), mimeType: 'audio/pcm;rate=16000' }
                }));
            };
            mediaStreamSource.connect(audioWorkletNode);
            audioWorkletNode.connect(inputAudioContext.destination);
        }

        function stopAudioStreaming() {
            audioStream?.getTracks().forEach(track => track.stop());
            inputAudioContext?.state !== 'closed' && inputAudioContext?.close();
            audioWorkletNode?.port.close();
            audioStream = null;
            inputAudioContext = null;
            audioWorkletNode = null;
        }

        function updateStatus(message, type = 'info') {
            statusBar.textContent = message;
            statusBar.style.color = type === 'error' ? '#D32F2F' : (type === 'listening' ? '#388E3C' : '#888');
        }

        function clearChat() { 
            messagesContainer.innerHTML = '';
            addWelcomeMessage();
        }

        function addWelcomeMessage() {
            addMessage(`¡Hola! ¿Qué tal? Soy tu asistente. Presioná el micrófono y charlemos.`, 'assistant');
        }
        
        async function decodeAndPlayAudio(base64String) {
            try {
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const dataInt16 = new Int16Array(bytes.buffer);
                const frameCount = dataInt16.length;
                const buffer = outputAudioContext.createBuffer(1, frameCount, 24000);
                const channelData = buffer.getChannelData(0);
                for (let i = 0; i < frameCount; i++) {
                    channelData[i] = dataInt16[i] / 32768.0;
                }
                const source = outputAudioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(outputAudioContext.destination);
                source.addEventListener('ended', () => sources.delete(source));
                nextStartTime = Math.max(nextStartTime, outputAudioContext.currentTime);
                source.start(nextStartTime);
                nextStartTime += buffer.duration;
                sources.add(source);
            } catch (error) { console.error("Error al reproducir audio:", error); }
        }

        function uint8ArrayToBase64(bytes) {
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }
    </script>
</body>
</html>
